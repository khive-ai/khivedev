# Copyright (c) 2025, HaiyangLi <quantocean.li at gmail dot com>
#
# SPDX-License-Identifier: MIT

from __future__ import annotations

import asyncio
import logging
from typing import Any, Callable, ClassVar, List, Optional

from lionagi.libs.concurrency import shield
from lionagi.protocols.types import Node
from pydantic import field_validator
from typing_extensions import TypedDict

__all__ = (
    "HookEvent",
    "HookEventContent",
    "hook_event_logger",
    "shield",
    "HookEventBroadcaster",
)


class HookEventBroadcaster:
    """Real-time event broadcasting system for hook events."""

    _instance: ClassVar["HookEventBroadcaster | None"] = None
    _subscribers: ClassVar[List[Callable[[Any], None]]] = []
    _async_subscribers: ClassVar[List[Callable[[Any], Any]]] = []

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    @classmethod
    def subscribe(cls, callback: Callable[[Any], None]) -> None:
        """Subscribe to hook events with sync callback."""
        if callback not in cls._subscribers:
            cls._subscribers.append(callback)

    @classmethod
    def subscribe_async(cls, callback: Callable[[Any], Any]) -> None:
        """Subscribe to hook events with async callback."""
        if callback not in cls._async_subscribers:
            cls._async_subscribers.append(callback)

    @classmethod
    def unsubscribe(cls, callback: Callable[[Any], None]) -> None:
        """Unsubscribe from hook events."""
        if callback in cls._subscribers:
            cls._subscribers.remove(callback)
        if callback in cls._async_subscribers:
            cls._async_subscribers.remove(callback)

    @classmethod
    async def broadcast(cls, event: "HookEvent") -> None:
        """Broadcast event to all subscribers."""
        # Sync callbacks
        for callback in cls._subscribers:
            try:
                callback(event)
            except Exception as e:
                print(f"Error in sync subscriber callback: {e}")

        # Async callbacks
        for callback in cls._async_subscribers:
            try:
                if asyncio.iscoroutinefunction(callback):
                    await callback(event)
                else:
                    callback(event)
            except Exception as e:
                print(f"Error in async subscriber callback: {e}")

    @classmethod
    def get_subscriber_count(cls) -> int:
        """Get total number of subscribers."""
        return len(cls._subscribers) + len(cls._async_subscribers)


class HookEventContent(TypedDict, total=False):
    event_type: str
    tool_name: str
    command: Optional[str]
    output: Optional[str]
    session_id: Optional[str]
    file_paths: list[str]
    metadata: dict[str, Any]


class HookEvent(Node):
    """Event generated by Claude Code hooks."""

    content: HookEventContent
    _initialized: ClassVar[bool] = False

    @field_validator("content", mode="before")
    def _validate_event_type(cls, value) -> dict:
        if value is None:
            raise ValueError("Content is required")

        if isinstance(value, dict):
            if "event_type" not in value:
                raise ValueError("Event type is required")
            if "tool_name" not in value:
                raise ValueError("Tool name is required")
            return value
        else:
            raise ValueError("Content must be a dictionary")

    async def save(self):
        # Save to database
        result = await self.adapt_to_async(
            obj_key="lionagi_async_pg",
            dsn="sqlite+aiosqlite:///claude_hooks.db",
            table="hook_events",
        )

        # Broadcast to real-time subscribers
        await HookEventBroadcaster.broadcast(self)

        return result

    @classmethod
    async def get_all(cls, limit: int | None = None):
        """Get all hook events from database."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )

    @classmethod
    async def get_recent(cls, limit: int = 100) -> list[HookEvent]:
        """Get recent hook events."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
            "order_by": "created_at DESC",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )

    @classmethod
    async def get_by_type(
        cls, event_type: str, limit: int | None = None
    ) -> list[HookEvent]:
        """Get hook events by event type."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
            "where": f"content->>'event_type' = '{event_type}'",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )

    @classmethod
    async def get_by_session(
        cls, session_id: str, limit: int | None = None
    ) -> list[HookEvent]:
        """Get hook events by session ID."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
            "where": f"content->>'session_id' = '{session_id}'",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )

    @classmethod
    async def get_since(
        cls, timestamp: str, limit: int | None = None
    ) -> list[HookEvent]:
        """Get hook events since a specific timestamp."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
            "where": f"created_at >= '{timestamp}'",
            "order_by": "created_at DESC",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )


def _setup_logger() -> logging.Logger:
    """Set up Claude Code hook event logger."""
    logger = logging.getLogger("ClaudeHooks")
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            "ü™ù [CLAUDE-HOOKS] %(asctime)s - %(levelname)s - %(message)s"
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
    return logger


def _initialize_adapter():
    """Initialize the async adapter for SQLite database."""
    try:
        from lionagi.adapters.async_postgres_adapter import LionAGIAsyncPostgresAdapter

        if not HookEvent._initialized:
            HookEvent.register_async_adapter(LionAGIAsyncPostgresAdapter)
            HookEvent._initialized = True
            print("‚úÖ Database adapter initialized successfully")
    except Exception as e:
        print(f"‚ö†Ô∏è  Warning: Could not initialize database adapter: {e}")


_initialize_adapter()

hook_event_logger = _setup_logger()

# Register the class with the adapter system
HookEvent = HookEvent
